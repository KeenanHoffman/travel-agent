#!/bin/bash

# set -x
red=`tput setaf 1`
green=`tput setaf 2`
reset=`tput sgr0`

conf_dir=~/.travel-agent

init(){
  # Check that ego is installed
  if ! type "ego" > /dev/null; then
    echo "${green}you must install ego${reset}"
    exit 1
  fi

  # Check that ginkgo is installed
  if ! type "ginkgo" > /dev/null; then
    echo "you must install ginkgo"
    exit 1
  fi

  go get github.com/onsi/ginkgo/ginkgo
  go get github.com/benbjohnson/ego/cmd/ego
  go get github.com/compozed/travel-agent/models
}

target(){
  TARGET=$1

  if [  -z "$TARGET" ]
    then
      echo "${red}You must provide a concourse target${reset}"
      echo ''
      echo 'USAGE: ./travel-agent target CONCOURSE_TARGET'
      exit 1
  fi

  mkdir -p $conf_dir
  echo $TARGET > $conf_dir/TARGET
}

bootstrap() {
  NAME=$1
  BASE_DIR=$2

  echo $NAME

  if [  -z "$NAME" ]
    then
      echo "${red}You must provide a name${reset}"
      echo ''
      echo 'USAGE: ./travel-agent bootstrap NAME'
      exit 1
  fi

  if [  -z "$BASE_DIR" ]
    then
      BASE_DIR="."
  fi
  mkdir -p $BASE_DIR
  pushd $BASE_DIR

  mkdir -p ci
  mkdir -p ci/manifest
  mkdir -p ci/manifest/assets

  cat > ci/manifest/assets/dev.yml <<- EOM
---
jobs:
- name: $NAME-dev
  serial: true
  public: true
  plan: []

resources: 
- name: dev-$NAME-deployment
  type: bosh-deployment

EOM

  cat > ci/manifest/assets/prod.yml <<- EOM
---
jobs:
- name: $NAME-prod
  serial: true
  public: true
  plan: []

resources:
- name: prod-$NAME-deployment
  type: bosh-deployment

EOM

  cat > ci/manifest/manifest.ego <<- EOM
<%! func ManifestTmpl(w io.Writer, envs []Env) error %>
<%% import . "github.com/compozed/travel-agent/models" %%>
---
jobs:
<% for _, env := range envs { %>
- name: <%= fmt.Sprintf("$NAME-%s", env.Name) %>
  serial: true
  public: true
  plan: []
<% } %>
resources:
<% for _, env := range envs { %>
- name: <%= fmt.Sprintf("%s-$NAME-deployment", env.Name) %>
  type: bosh-deployment
<% } %>
EOM

  cat > ci/manifest/.gitignore <<- EOM
  manifest
  manifest.go
EOM

  cat > ci/manifest/manifest_suite_test.go <<- EOM
  package main_test

  import (
    . "github.com/onsi/ginkgo"
    . "github.com/onsi/gomega"
    "github.com/onsi/gomega/gexec"
    "testing"
  )

  var manifestPath string
  var _ = BeforeSuite(func() {
    var err error

    manifestPath, err = gexec.Build("../manifest")
    Ω(err).ShouldNot(HaveOccurred())
  })

  var _ = AfterSuite(func() {
    gexec.CleanupBuildArtifacts()
  })

  func TestCi(t *testing.T) {
    RegisterFailHandler(Fail)
    RunSpecs(t, "Ci Suite")
  }
EOM

cat > ci/manifest/manifest_test.go <<- EOM
  package main_test

  import (
    . "../manifest"
    "bytes"
    "fmt"
    . "github.com/compozed/travel-agent/models"
    . "github.com/onsi/ginkgo"
    . "github.com/onsi/gomega"
    "gopkg.in/yaml.v2"
    "io/ioutil"
  )

  var _ = Describe("Manifest generation", func() {
    envs := []Env{
      Env{Name: "dev"},
      Env{Name: "prod"},
    }

    for index, env := range envs {
      envLocal := env
      indexLocal := index
      var actualManifest map[interface{}]interface{}

      JustBeforeEach(func() {
        var err error
        var buf bytes.Buffer

        if indexLocal > 0 {
          envLocal.DependsOn = fmt.Sprintf("${NAME}-%s", envs[indexLocal-1].Name)
        }

        err = ManifestTmpl(&buf, []Env{envLocal})
        Ω(err).ShouldNot(HaveOccurred())

        err = yaml.Unmarshal(buf.Bytes(), &actualManifest)
        Expect(actualManifest).ShouldNot(BeNil())

        Ω(err).ShouldNot(HaveOccurred(), "There is a problem in your ego template")
      })

      Describe("When rendering jobs", func() {
        expectedJobs := ReadYAML(fmt.Sprintf("assets/%s.yml", envLocal.Name))["jobs"].([]interface{})

        for _, job := range expectedJobs {
          localExpectedJob := job.(map[interface{}]interface{})

          It(fmt.Sprintf("Should render %s", localExpectedJob["name"]), func() {
            jobName := localExpectedJob["name"].(string)

            actualJob := GetJob(actualManifest, jobName)

            Expect(actualJob).Should(Equal(localExpectedJob))
          })
        }

      })

      Describe("When rendering resources", func() {
        expectedResources := ReadYAML(fmt.Sprintf("assets/%s.yml", envLocal.Name))["resources"].([]interface{})

        for _, resource := range expectedResources {
          localExpectedResource := resource.(map[interface{}]interface{})

          It(fmt.Sprintf("Should render %s", localExpectedResource["name"]), func() {
            resourceName := localExpectedResource["name"].(string)

            actualResource := GetResource(actualManifest, resourceName)

            Expect(actualResource).Should(Equal(localExpectedResource))
          })
        }
      })
    }
  })

  func ReadYAML(filepath string) map[interface{}]interface{} {
    res := make(map[interface{}]interface{})
    source, err := ioutil.ReadFile(filepath)
    if err != nil {
      panic(err)
    }
    err = yaml.Unmarshal(source, &res)
    if err != nil {
      panic(err)
    }
    return res
  }

  func GetJob(manifest map[interface{}]interface{}, jobName string) map[interface{}]interface{} {
    return GetItem(manifest, "jobs", jobName)
  }

  func GetResource(manifest map[interface{}]interface{}, resourceName string) map[interface{}]interface{} {
    return GetItem(manifest, "resources", resourceName)
  }

  func GetItem(manifest map[interface{}]interface{}, itemType string, itemName string) map[interface{}]interface{} {
    items := manifest[itemType].([]interface{})
    var item map[interface{}]interface{}
    for i := 0; item == nil && i < len(items); i++ {
      item = items[i].(map[interface{}]interface{})
      if item["name"] != itemName {
        item = nil
      }
    }
    return item
  }
EOM

  popd 
}

book() {
  pushd ci/manifest
    clean

    # Compile .ego into manifest.go
    ego -package main -o manifest.go

    ln -s $GOPATH/src/github.com/compozed/travel-agent/main.go .


    # Run test suite to match template with assets/*
    ginkgo -r

    # deploy
    deploy
    clean
  popd

}

# Clean old atifacts
clean(){
  rm -f manifest.go manifest main.go
}

# Deploys new pipeline to concourse 
deploy(){
  target=$(cat $conf_dir/TARGET)
}

# Run test suite to match template with assets/*
run_tests(){
  ginkgo -r
}

# Deploys new pipeline to concourse 
deploy(){
  target=$(cat $conf_dir/TARGET)
  # travel_agent_conf_path=$2
  # stub_file=$3
  # pipeline_name=$4 

  # manifest=.tmp/concourse_deployment_manifest.yml
  # pre_merged_manifest=.tmp/pre_merged_manifest.yml

  # [ ! -d .tmp ] && mkdir .tmp 
  # go run manifest.go main.go $travel_agent_conf_path > $pre_merged_manifest
  # cp $pre_merged_manifest $manifest
  # spruce merge --prune config $pre_merged_manifest  $stub_file > $manifest
  # fly -t $target configure -c $manifest --paused=false $pipeline_name
}

help() {
cat << EOM

  Travel with Concourse to multiple enviroments without repeating yourself.
  TDD your pipeline templates and create jobs and resources for 1..N environments.

  Running travel agent:

    travel-agent SUBCOMMAND

  Subcommands:

    help
    target      - Sets concourse target. EG: https://1.2.3.4:9090
    bootstrap - Bootstraps a new ci folder with travel agent structure
    book  - test and deploy your pipeline template (manifest.ego) against 2 dummy assets(dev and prod)
EOM
}

if [[ $1 =~ ^(bootstrap|book|target|help)$ ]]; then
  case $1 in
    help)
      help
      ;;
    target)
      target $2
      ;;
    bootstrap)
      bootstrap $2 $3
      ;;
    book)
      book 
      ;;
  esac
else
  echo "Invalid subcommand $1" >&2
  exit 1
fi
